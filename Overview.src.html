<!doctype html>
<html lang=en-US>
<meta charset=utf-8>
<title>Encoding Standard</title>
<style>
 pre.idl { border:solid thin; background:#eee; color:#000; padding:0.5em }
 pre.idl :link, pre.idl :visited { color:inherit; background:transparent }
 pre code { color:inherit; background:transparent }
 .example { margin-left:1em; padding-left:1em; border-left:double; color:#222; background:#fcfcfc }
 .note { margin-left:2em; font-weight:bold; font-style:italic; color:#008000 }
 p.note::before { content:"Note: " }
 .XXX { padding:.5em; border:solid #f00 }
 /*p.XXX::before { content:"Issue: " }*/
 dl.switch { padding-left:2em }
 dl.switch > dt { text-indent:-1.5em }
 dl.switch > dt:before { content:'\21AA'; padding:0 0.5em 0 0; display:inline-block; width:1em; text-align:right; line-height:0.5em }
 dl.domintro { color: green; margin: 2em 0 2em 2em; padding: 0.5em 1em; border: none; background: #DDFFDD; }
 dl.domintro dt, dl.domintro dt * { color: black; text-decoration: none; }
 dl.domintro dd { margin: 0.5em 0 1em 2em; padding: 0; }
 dl.domintro dd p { margin: 0.5em 0; }
 dl.domintro:before { display: table; margin: -1em -0.5em -0.5em auto; width: auto; content: 'This box is non-normative. Implementation requirements are given below this box.'; color: red; border: solid 2px; background: white; padding: 0 0.25em; }
 em.ct { text-transform:lowercase; font-variant:small-caps; font-style:normal }
 dfn { font-weight:bold; font-style:normal }
 code { color:orangered }
 code :link, code :visited { color:inherit }
 hr:not(.top) { display:block; background:none; border:none; padding:0; margin:2em 0; height:auto }
 table { border-collapse:collapse; border-style:hidden hidden none hidden }
 table thead { border-bottom:solid }
 table tbody th:first-child { border-left:solid }
 table td, table th { border-left:solid; border-right:solid; border-bottom:solid thin; vertical-align:top; padding:0.2em }
 .encoding th, .encoding td { font-family:monospace }

 .warning { color: red; background: transparent; font-weight: bolder; font-style: italic; }
 .warning p:first-child { margin-top: 0; }
 .warning p:last-child { margin-bottom: 0; }
 .warning:before { font-style: normal; }
 p.warning:before { content: '\26A0 Warning! '; }
</style>
<style>
 @media print { [data-anolis-spec]::after { content:"[" attr(data-anolis-spec) "]"; font-size:.6em; vertical-align:super; text-transform:uppercase } }
</style>
<link rel=stylesheet href="http://www.whatwg.org/style/specification">

<div class=head>

<h1>Encoding</h1>
<h2 class="no-num no-toc">Living Draft &mdash; [DATE: 01 Jan 1901]</h2>

<dl>
 <dt>This Version:
 <dd><a href="http://dvcs.w3.org/hg/encoding/raw-file/tip/Overview.html">http://dvcs.w3.org/hg/encoding/raw-file/tip/Overview.html</a>

 <dt>Participate:</dt>
 <dd>Send feedback to <a href="http://www.whatwg.org/mailing-list">whatwg@whatwg.org</a>
 (<a href="http://www.whatwg.org/mailing-list#specs">archives</a>) or
 <a href="https://www.w3.org/Bugs/Public/enter_bug.cgi?product=Web%20Platform%20%28other%29&amp;component=Encoding">file a bug</a>
 (<a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=Web%20Platform%20%28other%29&amp;component=Encoding&amp;resolution=---">open bugs</a>)
 <dd><a href="http://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

 <dt>Editor:
 <dd class="vcard h-card">
  <a class="url u-url fn p-fn" lang="nl" href="http://annevankesteren.nl/">Anne van Kesteren</a>
  (<a class="org h-org" href="http://www.opera.com/">Opera Software ASA</a>)
  &lt;<a class="email u-email" href="mailto:annevk@opera.com">annevk@opera.com</a>>
</dl>

<p class=copyright><a rel="license" href="http://creativecommons.org/publicdomain/zero/1.0/"><img src="http://i.creativecommons.org/p/zero/1.0/80x15.png" alt="CC0"></a>
To the extent possible under law, the editors have waived all copyright and
related or neighboring rights to this work. In addition, as of
[DATE: 01 Jan 1901], the editors have made this specification available
under the
<a rel="license"
href="http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0">Open Web Foundation Agreement Version 1.0</a>,
which is available at
http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0.

</div>

<hr class="top">


<h2 class="no-num no-toc">Table of Contents</h2>

<!--toc-->


<h2>Preface</h2>

<p>While encodings for the web platform have been defined to some extent,
implementations have not always implemented them in the same way, have not
always used the same labels, and often differ in dealing with undefined
areas of encodings. This standard attempts to fill those gaps so that new
implementations do not have to reverse engineer encoding implementations of
the market leaders.</p>


<h2>Conformance</h2>

<p>All diagrams, examples, and notes in this specification are
non-normative, as are all sections explicitly marked non-normative.
Everything else in this specification is normative.

<p>The key words "MUST", "MUST NOT", "REQUIRED", <!--"SHALL", "SHALL
NOT",--> "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
"OPTIONAL" in the normative parts of this document are to be
interpreted as described in RFC2119. For readability, these words do
not appear in all uppercase letters in this specification.
<span data-anolis-ref>RFC2119</span>

<p>Conformance requirements phrased as algorithms or specific steps
may be implemented in any manner, so long as the end result is
equivalent. (In particular, the algorithms defined in this
specification are intended to be easy to follow, and not intended to
be performant.)

<p id="hardwareLimitations">User agents may impose
implementation-specific limits on otherwise unconstrained inputs,
e.g. to prevent denial of service attacks, to guard against running
out of memory, or to work around platform-specific limitations.


<h2>Terminology</h2>

<p>A <dfn>code point</dfn> is a Unicode code point and is referenced as a
four-or-more digit hexadecimal value, typically preceded by "U+". E.g. U+0020.

<p>The <dfn>fallback code point</dfn> is U+FFFD.

<p>A <dfn>byte</dfn> is referenced as a double-digit hexadecimal value,
typically preceded by "0x". E.g. 0xAA. A byte never consists of more, nor
less than exactly eight bits (at least as far as the web platform is
concerned).

<p>The <dfn>space characters</dfn>, for the purposes of this specification,
are U+0020 SPACE, U+0009 CHARACTER TABULATION (tab), U+000A LINE FEED (LF),
U+000C FORM FEED (FF), and U+000D CARRIAGE RETURN (CR).

<p>Comparing two strings in an <dfn>ASCII case-insensitive</dfn> manner
means comparing them exactly, code point for code point, except that the
characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to
LATIN CAPITAL LETTER Z) and the corresponding characters in the range
U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are
considered to also match.


<h2>Encodings</h2>

<p>An <dfn title=concept-encoding>encoding</dfn> defines a mapping from a
code point to one or more bytes (and vice versa). Each
<span title=concept-encoding>encoding</span> has a
<dfn title=concept-encoding-name>name</dfn>, one or more
<dfn title=concept-encoding-label>labels</dfn>, and potentially a
<dfn title=concept-encoding-map>map</dfn>. A
<span title=concept-encoding-map>map</span> is a newline-separated (U+000A)
resource, where each line starts with one or more bytes, followed by a
U+0009 code point, followed by a code point, followed by a U+0009
code point, followed by either the Unicode Character Name or
&lt;Private Use>, which is preceded by a U+0023 code point.

<p>Each <span title=concept-encoding>encoding</span> also has a
<dfn>decoder</dfn> and <dfn>encoder</dfn> algorithm.

<p>A <span>decoder</span> algorithm takes a stream of bytes and emits a
stream of code points. It has an associated
<dfn>fatal flag</dfn> that when set will make the algorithm return failure
if an invalid byte or byte sequence is in the stream. The
<dfn>byte pointer</dfn> is initially zero, pointing to the first byte in
the stream. It cannot be negative. It can be increased and decreased to
point to other bytes in the stream. The <dfn>EOF byte</dfn> is a
conceptual byte representing the last byte in a stream. The
<span>byte pointer</span> cannot point beyond the <span>EOF byte</span>.
The <dfn>EOF code point</dfn> is a conceptual code point that is emitted
once the stream of bytes is handled in its entirety. Apart from returning
failure, a <span>decoder</span> can end by emitting a code point, or the
word continue. Unless it returns failure, or the <span>EOF code point</span>
is emitted, the <span>decoder</span> algorithm must be invoked again.

<p>An <span>encoder</span> algorithm takes a
stream of code points and emits a stream of bytes. It will fail when
a code point is passed for which it does not have a corresponding byte or
byte sequence. Analogously to a <span>decoder</span>, it has a
<dfn>code point pointer</dfn>. Again analogously, as long as the
<span>EOF byte</span> is not emitted, or failure is returned, the
<span>encoder</span> algorithm must be invoked for each byte or sequence of
bytes emitted.

<p class=note>The <span>fatal flag</span> is for XML, which
considers such an error a well-formed violation. Other formats such as HTML
will use <span title="fallback code point">fallback code points</span> for
such errors and carry on.

<p class=note>Pre-processing is required to make an <span>encoder</span>
not fail (e.g. for HTML forms).

<hr>

<p>The table below lists all <span title=concept-encoding>encodings</span>
and their <span title=concept-encoding-label>labels</span> user agents must
support. User agents must not support any other
<span title=concept-encoding>encodings</span> or
<span title=concept-encoding-label>labels</span>.

<p>To <dfn title=concept-encoding-get>get an encoding</dfn> from a string
<var title>label</var>, run these steps:

<ol>
 <li><p>Remove any leading and trailing <span>space characters</span> from
 <var title>label</var>.

 <li><p>If <var title>label</var> is an <span>ASCII case-insensitive</span>
 match for any of the <span title=concept-encoding-label>labels</span>
 listed in the table below, return the corresponding
 <span title=concept-encoding>encoding</span> and terminate these steps.

 <li><p>Return failure.
</ol>

<p class=note>This algorithm is different from the one defined
in
<a href="http://www.unicode.org/reports/tr22/tr22-7.html#Charset_Alias_Matching">section 1.4 of Unicode Technical Standard #22</a>
as that algorithm is incompatible with legacy content.

<table>
 <thead>
  <tr>
   <th><span title=concept-encoding-name>Name</span>
   <th><span title=concept-encoding-label>Labels</span>
 <tbody>
  <tr><th colspan=2><a href=#the-encoding>The Encoding</a>
  <tr>
   <td rowspan=3><span>utf-8</span>
   <td>"<code title>unicode-1-1-utf-8</code>"
  <tr><td>"<code title>utf-8</code>"
  <tr><td>"<code title>utf8</code>"
 <tbody>
  <tr><th colspan=2><a href=#legacy-single-byte-encodings>Legacy single-byte encodings</a>
  <tr>
   <td rowspan=2><span>ibm864</span>
   <td>"<code title>cp864</code>"
  <tr><td>"<code title>ibm864</code>"
  <tr>
   <td rowspan=2><span>ibm866</span>
   <td>"<code title>cp866</code>"
  <tr><td>"<code title>ibm866</code>"
  <tr>
   <td rowspan=7><span>iso-8859-2</span>
   <td>"<code title>csisolatin2</code>"
  <tr><td>"<code title>iso-8859-2</code>"
  <tr><td>"<code title>iso-ir-101</code>"
  <tr><td>"<code title>iso8859-2</code>"
  <tr><td>"<code title>iso_8859-2</code>"
  <tr><td>"<code title>l2</code>"
  <tr><td>"<code title>latin2</code>"
  <tr>
   <td rowspan=6><span>iso-8859-3</span>
   <td>"<code title>csisolatin3</code>"
  <tr><td>"<code title>iso-8859-3</code>"
  <tr><td>"<code title>iso-ir-109</code>"
  <tr><td>"<code title>iso_8859-3</code>"
  <tr><td>"<code title>l3</code>"
  <tr><td>"<code title>latin3</code>"
  <tr>
   <td rowspan=6><span>iso-8859-4</span>
   <td>"<code title>csisolatin4</code>"
  <tr><td>"<code title>iso-8859-4</code>"
  <tr><td>"<code title>iso-ir-110</code>"
  <tr><td>"<code title>iso_8859-4</code>"
  <tr><td>"<code title>l4</code>"
  <tr><td>"<code title>latin4</code>"
  <tr>
   <td rowspan=5><span>iso-8859-5</span>
   <td>"<code title>csisolatincyrillic</code>"
  <tr><td>"<code title>cyrillic</code>"
  <tr><td>"<code title>iso-8859-5</code>"
  <tr><td>"<code title>iso-ir-144</code>"
  <tr><td>"<code title>iso_8859-5</code>"
  <tr>
   <td rowspan=6><span>iso-8859-6</span>
   <td>"<code title>arabic</code>"
  <tr><td>"<code title>csisolatinarabic</code>"
  <tr><td>"<code title>ecma-114</code>"
  <tr><td>"<code title>iso-8859-6</code>"
  <tr><td>"<code title>iso-ir-127</code>"
  <tr><td>"<code title>iso_8859-6</code>"
  <tr>
   <td rowspan=8><span>iso-8859-7</span>
   <td>"<code title>csisolatingreek</code>"
  <tr><td>"<code title>ecma-118</code>"
  <tr><td>"<code title>elot_928</code>"
  <tr><td>"<code title>greek</code>"
  <tr><td>"<code title>greek8</code>"
  <tr><td>"<code title>iso-8859-7</code>"
  <tr><td>"<code title>iso-ir-126</code>"
  <tr><td>"<code title>iso_8859-7</code>"
  <tr>
   <td rowspan=7><span>iso-8859-8</span>
   <td>"<code title>csisolatinhebrew</code>"
  <tr><td>"<code title>hebrew</code>"
  <tr><td>"<code title>iso-8859-8</code>"
  <tr><td>"<code title>iso-8859-8-i</code>"
  <tr><td>"<code title>iso-ir-138</code>"
  <tr><td>"<code title>iso_8859-8</code>"
  <tr><td>"<code title>visual</code>"
  <tr>
   <td rowspan=6><span>iso-8859-10</span>
   <td>"<code title>csisolatin6</code>"
  <tr><td>"<code title>iso-8859-10</code>"
  <tr><td>"<code title>iso-ir-157</code>"
  <tr><td>"<code title>iso8859-10</code>"
  <tr><td>"<code title>l6</code>"
  <tr><td>"<code title>latin6</code>"
  <tr>
   <td><span>iso-8859-13</span>
   <td>"<code title>iso-8859-13</code>"
  <tr>
   <td rowspan=2><span>iso-8859-14</span>
   <td>"<code title>iso-8859-14</code>"
  <tr><td>"<code title>iso8859-14</code>"
  <tr>
   <td rowspan=2><span>iso-8859-15</span>
   <td>"<code title>iso-8859-15</code>"
  <tr><td>"<code title>iso_8859-15</code>"
  <tr>
   <td><span>iso-8859-16</span>
   <td>"<code title>iso-8859-16</code>"
  <tr>
   <td rowspan=2><span>koi8-r</span>
   <td>"<code title>koi8-r</code>"
  <tr><td>"<code title>koi8_r</code>"
  <tr>
   <td><span>koi8-u</span>
   <td>"<code title>koi8-u</code>"
  <tr>
   <td rowspan=4><span>macintosh</span>
   <td>"<code title>csmacintosh</code>"
  <tr><td>"<code title>mac</code>"
  <tr><td>"<code title>macintosh</code>"
  <tr><td>"<code title>x-mac-roman</code>"
  <tr>
   <td rowspan=3><span>windows-874</span>
   <td>"<code title>iso-8859-11</code>"
  <tr><td>"<code title>tis-620</code>"
  <tr><td>"<code title>windows-874</code>"
  <tr>
   <td rowspan=2><span>windows-1250</span>
   <td>"<code title>windows-1250</code>"
  <tr><td>"<code title>x-cp1250</code>"
  <tr>
   <td rowspan=2><span>windows-1251</span>
   <td>"<code title>windows-1251</code>"
  <tr><td>"<code title>x-cp1251</code>"
  <tr>
   <td rowspan=10><span>windows-1252</span>
   <td>"<code title>ansi_x3.4-1968</code>"
  <tr><td>"<code title>ascii</code>"
  <tr><td>"<code title>csisolatin1</code>"
  <tr><td>"<code title>iso-8859-1</code>"
  <tr><td>"<code title>iso8859-1</code>"
  <tr><td>"<code title>iso_8859-1</code>"
  <tr><td>"<code title>l1</code>"
  <tr><td>"<code title>latin1</code>"
  <tr><td>"<code title>us-ascii</code>"
  <tr><td>"<code title>windows-1252</code>"
  <tr>
   <td rowspan=2><span>windows-1253</span>
   <td>"<code title>cp1253</code>"
  <tr><td>"<code title>windows-1253</code>"
  <tr>
   <td rowspan=6><span>windows-1254</span>
   <td>"<code title>csisolatin5</code>"
  <tr><td>"<code title>iso-8859-9</code>"
  <tr><td>"<code title>iso-ir-148</code>"
  <tr><td>"<code title>l5</code>"
  <tr><td>"<code title>latin5</code>"
  <tr><td>"<code title>windows-1254</code>"
  <tr>
   <td rowspan=2><span>windows-1255</span>
   <td>"<code title>cp1255</code>"
  <tr><td>"<code title>windows-1255</code>"
  <tr>
   <td rowspan=2><span>windows-1256</span>
   <td>"<code title>cp1256</code>"
  <tr><td>"<code title>windows-1256</code>"
  <tr>
   <td><span>windows-1257</span>
   <td>"<code title>windows-1257</code>"
  <tr>
   <td rowspan=2><span>windows-1258</span>
   <td>"<code title>cp1258</code>"
  <tr><td>"<code title>windows-1258</code>"
  <tr>
   <td rowspan=2><span>x-mac-cyrillic</span>
   <td>"<code title>x-mac-cyrillic</code>"
  <tr><td>"<code title>x-mac-ukrainian</code>"
 <tbody>
  <tr><th colspan=2><a href=#legacy-multi-byte-chinese-(simplified)-encodings>Legacy multi-byte Chinese (simplified) encodings</a>
  <tr>
   <td rowspan=9><span>gbk</span>
   <td>"<code title>chinese</code>"
  <tr><td>"<code title>csgb2312</code>"
  <tr><td>"<code title>csiso58gb231280</code>"
  <tr><td>"<code title>gb2312</code>"
  <tr><td>"<code title>gb_2312</code>"
  <tr><td>"<code title>gb_2312-80</code>"
  <tr><td>"<code title>gbk</code>"
  <tr><td>"<code title>iso-ir-58</code>"
  <tr><td>"<code title>x-gbk</code>"
  <tr>
   <td><span>gb18030</span>
   <td>"<code title>gb18030</code>"
  <tr>
   <td><span>hz-gb-2312</span>
   <td>"<code title>hz-gb-2312</code>"
  <tr>
   <td rowspan=2><span>iso-2022-cn</span>
   <td>"<code title>iso-2022-cn</code>"
  <tr><td>"<code title>iso-2022-cn-ext</code>"
 <tbody>
  <tr><th colspan=2><a href=#legacy-multi-byte-chinese-(traditional)-encodings>Legacy multi-byte Chinese (traditional) encodings</a>
  <tr>
   <td rowspan=4><span>big5</span>
   <td>"<code title>big5</code>"
  <tr><td>"<code title>cn-big5</code>"
  <tr><td>"<code title>csbig5</code>"
  <tr><td>"<code title>x-x-big5</code>"
  <tr>
   <td><span>big5-hkscs</span>
   <td>"<code title>big5-hkscs</code>"
 <tbody>
  <tr><th colspan=2><a href=#legacy-multi-byte-japanese-encodings>Legacy multi-byte Japanese encodings</a>
  <tr>
   <td rowspan=3><span>euc-jp</span>
   <td>"<code title>cseucjpkdfmtjapanese</code>"
  <tr><td>"<code title>euc-jp</code>"
  <tr><td>"<code title>x-euc-jp</code>"
  <tr>
   <td rowspan=2><span>iso-2022-jp</span>
   <td>"<code title>csiso2022jp</code>"
  <tr><td>"<code title>iso-2022-jp</code>"
  <tr>
   <td rowspan=6><span>shift_jis</span>
   <td>"<code title>csshiftjis</code>"
  <tr><td>"<code title>ms_kanji</code>"
  <tr><td>"<code title>shift-jis</code>"
  <tr><td>"<code title>shift_jis</code>"
  <tr><td>"<code title>windows-31j</code>"
  <tr><td>"<code title>x-sjis</code>"
 <tbody>
  <tr><th colspan=2><a href=#legacy-multi-byte-korean-encodings>Legacy multi-byte Korean encodings</a>
  <tr>
   <td rowspan=9><span>euc-kr</span>
   <td>"<code title>csksc56011987</code>"
  <tr><td>"<code title>csueckr</code>"
  <tr><td>"<code title>euc-kr</code>"
  <tr><td>"<code title>iso-ir-149</code>"
  <tr><td>"<code title>korean</code>"
  <tr><td>"<code title>ks_c_5601-1989</code>"
  <tr><td>"<code title>ksc5601</code>"
  <tr><td>"<code title>ksc_5601</code>"
  <tr><td>"<code title>windows-949</code>"
  <tr>
   <td rowspan=2><span>iso-2022-kr</span>
   <td>"<code title>csiso2022kr</code>"
  <tr><td>"<code title>iso-2022-kr</code>"
 <tbody>
  <tr><th colspan=2><a href=#legacy-utf-16-encodings>Legacy utf-16 encodings</a>
  <tr>
   <td rowspan=2><span>utf-16</span>
   <td>"<code title>utf-16</code>"
  <tr><td>"<code title>utf-16le</code>"
  <tr>
   <td><span>utf-16be</span>
   <td>"<code title>utf-16be</code>"
</table>


<h2>Decode and encode</h2>

<p class=note>The algorithms <span>decode</span>, <span>utf-8 decode</span>,
and <span>encode</span> are intended for usage by other specifications.
<span>utf-8 decode</span> is to be used by new formats.

<p>To <dfn>decode</dfn> a byte stream <var title>stream</var> using
fallback label <var title>label</var>, these steps must be run:

<ol>
 <li><p>Let <var title>encoding</var> be the result of
 <span title=concept-encoding-get>get an encoding</span> for
 <var title>label</var>.

 <li><p>Let <var title>offset</var> be 0.

 <li>
  <p>For each of the rows in the following table, starting with the first
  one and going down, if the first bytes of <var title>stream</var> match
  all the bytes given in the first column (ergo <var title>stream</var>
  contains at least 2 or 3 bytes), then set <var title>encoding</var> to the
  <span title=concept-encoding>encoding</span> given in the cell in the
  second column of that row, and set <var title>offset</var> to the offset
  given in the cell in the third column of that row.

  <table>
   <tr><th>Byte order mark<th>Encoding<th>Offset
   <tr><td>0xFF 0xFE<td><span>utf-16</span><td>2
   <tr><td>0xFE 0xFF<td><span>utf-16be</span><td>2
   <tr><td>0xEF 0xBB 0xBF<td><span>utf-8</span><td>3
  </table>

  <p class=note>For compatibility with deployed content, the byte order mark
  is considered more authoritative than anything else.

 <li><p>Return the result of running <var title>encoding</var>'s
 <span>decoder</span> with <span>byte pointer</span> set to
 <var title>offset</var>, on <var title>stream</var>.
</ol>

<p>To <dfn>utf-8 decode</dfn> a byte stream <var title>stream</var>, these
steps must be run:

<ol>
 <li><p>Let <var title>offset</var> be 0.

 <li><p>If <var title>stream</var> contains at least three bytes and its
 first three bytes match 0xEF 0xBB 0xBF, set <var title>offset</var> to 3.

 <li><p>Return the result of running the <span>utf-8 decoder</span> with
 <span>byte pointer</span> set to <var title>offset</var>, on
 <var title>stream</var>.
</ol>

<p>To <dfn>encode</dfn> a code point stream <var title>stream</var> using
label <var title>label</var>, these steps must be run:

<ol>
 <li><p>Let <var title>encoding</var> be the result of
 <span title=concept-encoding-get>get an encoding</span> for
 <var title>label</var>.

 <li><p>Return the result of running <var title>encoding</var>'s
 <span>encoder</span> on <var title>stream</var>.
</ol>


<h2>The encoding</h2>

<p>New content and formats must exclusively use the <span>utf-8</span>
<span title=concept-encoding>encoding</span>.


<h3><dfn>utf-8</dfn></h3>

<!--
http://www.whatwg.org/specs/web-apps/current-work/multipage/infrastructure.html#utf-8
Unicode
-->

<p>The <dfn>utf-8 code point</dfn>, <dfn>utf-8 bytes seen</dfn>,
<dfn>utf-8 bytes needed</dfn>, and <dfn>utf-8 lower boundary</dfn> concepts
are all initially 0.

<p>The <dfn>utf-8 decoder</dfn> (<span>decoder</span> for <span>utf-8</span>) is:

<ol>
 <li><p>Let <var title>byte</var> be <span>byte pointer</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span>,
 <span>utf-8 bytes needed</span> is not 0, and the <span>fatal flag</span>
 is set, return failure.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span> and
 <span>utf-8 bytes needed</span> is not 0, emit the
 <span>fallback code point</span>, followed by the
 <span>EOF code point</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span>, emit the
 <span>EOF code point</span>.

 <li><p>Increase the <span>byte pointer</span>.

 <li>
  <p>If <span>utf-8 bytes needed</span> is 0, based on
  <var title>byte</var>:

  <dl class=switch>
   <dt>0x00 to 0x7F
   <dd><p>Emit <var title>byte</var> as code point.

   <dt>0xC0 to 0xDF
   <dd><p>Set <span>utf-8 bytes needed</span> to 1,
   <span>utf-8 lower boundary</span> to 0x80, and
   <span>utf-8 code point</span> to <var title>byte</var> &minus; 0xC0.

   <dt>0xE0 to 0xEF
   <dd><p>Set <span>utf-8 bytes needed</span> to 2,
   <span>utf-8 lower boundary</span> to 0x800, and
   <span>utf-8 code point</span> to <var title>byte</var> &minus; 0xE0.

   <dt>0xF0 to 0xF7
   <dd><p>Set <span>utf-8 bytes needed</span> to 3,
   <span>utf-8 lower boundary</span> to 0x10000, and
   <span>utf-8 code point</span> to <var title>byte</var> &minus; 0xF0.

   <dt>0xF8 to 0xFB
   <dd><p>Set <span>utf-8 bytes needed</span> to 4,
   <span>utf-8 lower boundary</span> to 0x200000, and
   <span>utf-8 code point</span> to <var title>byte</var> &minus; 0xF8.

   <dt>0xFC to 0xFD
   <dd><p>Set <span>utf-8 bytes needed</span> to 5,
   <span>utf-8 lower boundary</span> to 0x4000000, and
   <span>utf-8 code point</span> to <var title>byte</var> &minus; 0xFC.

   <dt>Otherwise
   <dd><p>Emit the <span>fallback code point</span>.
  </dl>

  <p>Then (<var title>byte</var> was in the range 0xC0 to 0xFD) set
  <span>utf-8 code point</span> to <span>utf-8 code point</span> &times;
  64<sup><span>utf-8 bytes needed</span></sup> and continue.

 <li>
  <p>If <var title>byte</var> is not in the range 0x80 to 0xBF, run these
  substeps:

  <ol>
   <li><p>If the <span>fatal flag</span> is set, return failure.

   <li><p>Set <span>utf-8 code point</span>,
   <span>utf-8 bytes needed</span>, <span>utf-8 bytes seen</span>, and
   <span>utf-8 lower boundary</span> to 0.

   <li><p>Decrease the <span>byte pointer</span> by one.

   <li><p>Emit the <span>fallback code point</span>.
  </ol>

 <li>
  <p>Increase <span>utf-8 bytes seen</span> by one and set
  <span>utf-8 code point</span> to
  <span>utf-8 code point</span> + (<var title>byte</var> - 0x80) &times;
  64<sup><span>utf-8 bytes needed</span> &minus; <span>utf-8 bytes seen</span></sup>

 <li><p>If <span>utf-8 bytes seen</span> is not equal to
 <span>utf-8 bytes needed</span>, continue.

 <li><p>Let <var title>code point</var> be <span>utf-8 code point</span> and
 <var title>lower boundary</var> be <span>utf-8 lower boundary</span>

 <li><p>Set <span>utf-8 code point</span>,
 <span>utf-8 bytes needed</span>, <span>utf-8 bytes seen</span>, and
 <span>utf-8 lower boundary</span> to 0.

 <li><p>If <var title>code point</var> is equal or greater than
 <var title>lower boundary</var>, equal or smaller than 0x10FFFF, and is not
 in the range 0xD800 to 0xDFFF, emit <var title>code point</var>.

 <li><p>If the <span>fatal flag</span> is set, return failure.

 <li><p>Emit the <span>fallback code point</span>.
</ol>


<p>The <dfn>utf-8 encoder</dfn> (<span>encoder</span> for <span>utf-8</span>) is:

<ol>
 <li><p>Let <var title>code point</var> be <span>code point pointer</span>.

 <li><p>If <var title>code point</var> is in the range 0xD800 to 0xDFFF,
 return failure.

 <li><p>If <var title>code point</var> is the <span>EOF code point</span>,
 emit the <span>EOF byte</span>.

 <li><p>Increase the <span>code point pointer</span> by one.

 <li><p>If <var title>code point</var> is in the range U+0000 to U+007F,
 emit a byte whose value is <var title>code point</var>.

 <li>
  <p>Set <var title>count</var> and <var title>offset</var> based on the
  range <var title>code point</var> is in:

  <dl class=switch>
   <dt>U+0080 to U+07FF
   <dd>1 and 0xC0
   <dt>U+0800 to U+FFFF
   <dd>2 and 0xE0
   <dt>U+10000 to U+10FFFF
   <dd>3 and 0xF0
  </dl>

 <li><p>Let <var title>bytes</var> be a list of bytes whose first byte is
 <var title>code point</var> divided by
 64<sup><var title>count</var></sup> (as integers) + <var title>offset</var>.

 <li>
  <p>Run these substeps while <var title>count</var> is greater than 0:

  <ol>
   <li><p>Set <var title>temp</var> to <var title>code point</var> divided
   by 64<sup><var title>count</var> &minus; 1</sup> (as integers).

   <li><p>Append to <var title>bytes</var> 0x80 + the remainder of dividing
   <var title>temp</var> by 64<sup><var title>count</var></sup> (as integers).

   <li><p>Decrease <var title>count</var> by one.
  </ol>

 <li><p>Emit a sequence of bytes <var title>bytes</var>, in list order.
</ol>


<h2>Legacy single-byte encodings</h2>

<p>An <span title=concept-encoding>encoding</span> where each byte is
either a single code point or nothing, is a
<dfn>single-byte encoding</dfn>. These are the
<span title="single-byte encoding">single-byte encodings</span> and their
corresponding <span title=concept-encoding-map>map</span>:

<table>
 <tr><th><span title=concept-encoding-name>Name</name><th><span title=concept-encoding-map>Map</span>
 <tr><td><dfn>ibm864</dfn><td><a href=map-ibm864.txt>map-ibm864.txt</a>
 <tr><td><dfn>ibm866</dfn><td><a href=map-ibm866.txt>map-ibm866.txt</a>
 <tr><td><dfn>iso-8859-2</dfn><td><a href=map-iso-8859-2.txt>map-iso-8859-2.txt</a>
 <tr><td><dfn>iso-8859-3</dfn><td><a href=map-iso-8859-3.txt>map-iso-8859-3.txt</a>
 <tr><td><dfn>iso-8859-4</dfn><td><a href=map-iso-8859-4.txt>map-iso-8859-4.txt</a>
 <tr><td><dfn>iso-8859-5</dfn><td><a href=map-iso-8859-5.txt>map-iso-8859-5.txt</a>
 <tr><td><dfn>iso-8859-6</dfn><td><a href=map-iso-8859-6.txt>map-iso-8859-6.txt</a>
 <tr><td><dfn>iso-8859-7</dfn><td><a href=map-iso-8859-7.txt>map-iso-8859-7.txt</a>
 <tr><td><dfn>iso-8859-8</dfn><td><a href=map-iso-8859-8.txt>map-iso-8859-8.txt</a>
 <tr><td><dfn>iso-8859-10</dfn><td><a href=map-iso-8859-10.txt>map-iso-8859-10.txt</a>
 <tr><td><dfn>iso-8859-13</dfn><td><a href=map-iso-8859-13.txt>map-iso-8859-13.txt</a>
 <tr><td><dfn>iso-8859-14</dfn><td><a href=map-iso-8859-14.txt>map-iso-8859-14.txt</a>
 <tr><td><dfn>iso-8859-15</dfn><td><a href=map-iso-8859-15.txt>map-iso-8859-15.txt</a>
 <tr><td><dfn>iso-8859-16</dfn><td><a href=map-iso-8859-16.txt>map-iso-8859-16.txt</a>
 <tr><td><dfn>koi8-r</dfn><td><a href=map-koi8-r.txt>map-koi8-r.txt</a>
 <tr><td><dfn>koi8-u</dfn><td><a href=map-koi8-u.txt>map-koi8-u.txt</a>
 <tr><td><dfn>macintosh</dfn><td><a href=map-macintosh.txt>map-macintosh.txt</a>
 <tr><td><dfn>windows-874</dfn><td><a href=map-windows-874.txt>map-windows-874.txt</a>
 <tr><td><dfn>windows-1250</dfn><td><a href=map-windows-1250.txt>map-windows-1250.txt</a>
 <tr><td><dfn>windows-1251</dfn><td><a href=map-windows-1251.txt>map-windows-1251.txt</a>
 <tr><td><dfn>windows-1252</dfn><td><a href=map-windows-1252.txt>map-windows-1252.txt</a>
 <tr><td><dfn>windows-1253</dfn><td><a href=map-windows-1253.txt>map-windows-1253.txt</a>
 <tr><td><dfn>windows-1254</dfn><td><a href=map-windows-1254.txt>map-windows-1254.txt</a>
 <tr><td><dfn>windows-1255</dfn><td><a href=map-windows-1255.txt>map-windows-1255.txt</a>
 <tr><td><dfn>windows-1256</dfn><td><a href=map-windows-1256.txt>map-windows-1256.txt</a>
 <tr><td><dfn>windows-1257</dfn><td><a href=map-windows-1257.txt>map-windows-1257.txt</a>
 <tr><td><dfn>windows-1258</dfn><td><a href=map-windows-1258.txt>map-windows-1258.txt</a>
 <tr><td><dfn>x-mac-cyrillic</dfn><td><a href=map-x-mac-cyrillic.txt>map-x-mac-cyrillic.txt</a>
</table>

<hr>

<p>The <dfn>single-byte decoder</dfn> (<span>decoder</span> for
<span title="single-byte encoding">single-byte encodings</span>) is:

<ol>
 <li><p>Let <var title>byte</var> be <span>byte pointer</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span>, emit the
 <span>EOF code point</span>.

 <li><p>Increase the <span>byte pointer</span> by one.

 <li><p>If <var title>byte</var> is in the range 0x00 to 0x7F, emit a code
 point whose value is <var title>byte</var>.

 <li><p>If <var title>byte</var> is not in the
 <span title=concept-encoding-map>map</span> and the <span>fatal flag</span>
 is set, return failure.

 <li><p>If <var title>byte</var> is not in the
 <span title=concept-encoding-map>map</span>, emit the
 <span>fallback code point</span>.

 <li><p>Emit the code point given in the
 <span title=concept-encoding-map>map</span> for <var title>byte</var>.
</ol>

<p>The <dfn>single-byte encoder</dfn> (<span>encoder</span> for
<span title="single-byte encoding">single-byte encodings</span>) is:

<ol>
 <li><p>Let <var title>code point</var> be <span>code point pointer</span>.

 <li><p>If <var title>code point</var> is the <span>EOF code point</span>,
 emit the <span>EOF byte</span>.

 <li><p>Increase the <span>code point pointer</span> by one.

 <li><p>If <var title>code point</var> is in the range U+0000 to U+007F,
 emit a byte whose value is <var title>code point</var>.

 <li><p>If <var title>code point</var> is not listed in the
 <span title=concept-encoding-map>map</span>, return failure.

 <li><p>Emit the byte given in the
 <span title=concept-encoding-map>map</span> for
 <var title>code point</var>.
</ol>

<hr>

<p class=note>See also:
<a href="single-byte-research.html">single-byte research</a>.

<p class=note><span>Single-byte encoding</span> map data is also available as a
non-normative JSON resource: <a href=single-byte-encodings.json><code>single-byte-encodings.json</code></a>.


<h2>Legacy multi-byte Chinese (simplified) encodings</h2>

<p>The <dfn>gbk code point</dfn> for a given number is: ...


<h3><dfn>gbk</dfn></h3>

<p>The <dfn>gb18030 flag</dfn> flag is initially unset. It can only be set
by the <span>gb18030 decoder</span> and <span>gb18030 encoder</span>.

<p>The <dfn>gb18030 range table</dfn> is:

<table>
 <tr><th>Code point offset<th>From<th>To
 <tr><td>0x0452<!--200F--><td>0x81 0x30 0xD3 0x30<td>0x81 0x36 0xA5 0x31
 <tr><td>0x2643<!--2E80--><td>0x81 0x37 0xA8 0x39<td>0x81 0x38 0xFD 0x38
 <tr><td>0x361B<!--3917--><td>0x82 0x30 0xA6 0x33<td>0x82 0x30 0xF2 0x37
 <tr><td>0x3CE1<!--4055--><td>0x82 0x31 0xD4 0x38<td>0x82 0x32 0xAF 0x32
 <tr><td>0x4160<!--4336--><td>0x82 0x32 0xC9 0x37<td>0x82 0x32 0xF8 0x37
 <tr><td>0x44D7<!--464B--><td>0x82 0x33 0xA3 0x39<td>0x82 0x33 0xC9 0x31
 <tr><td>0x478E<!--4946--><td>0x82 0x33 0xE8 0x38<td>0x82 0x34 0x96 0x38
 <tr><td>0x49B8<!--4C76--><td>0x82 0x34 0xA1 0x31<td>0x82 0x34 0xE7 0x33
 <tr><td>0x9FA6<!--D7FF--><td>0x82 0x35 0x8F 0x33<td>0x83 0x36 0xC7 0x38
 <tr><td>0xE865<!--F92B--><td>0x83 0x36 0xD0 0x30<td>0x84 0x30 0x85 0x34
 <tr><td>0xFA2A<!--FE2F--><td>0x84 0x30 0x9C 0x38<td>0x84 0x31 0x85 0x37
 <tr><td>0xFFE6<!--FFFF--><td>0x84 0x31 0xA2 0x34<td>0x84 0x31 0xA4 0x39
 <tr><td>0x10000<!--10FFFF--><td>0x90 0x30 0x81 0x30<td>0xE3 0x32 0x9A 0x35
</table>

<p>The <dfn>gbk first</dfn>, <dfn>gbk second</dfn>, and
<dfn>gbk third</dfn>, are all initially 0x00.

<p>The <dfn>gbk decoder</dfn> (<span>decoder</span> for <span>gbk</span>) is:

<ol>
 <li><p>Let <var title>byte</var> be <span>byte pointer</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span> and
 <span>gbk first</span>, <span>gbk second</span>, and <span>gbk third</span>
 are 0x00, emit the <span>EOF code point</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span>, and one
 <span>gbk first</span>, <span>gbk second</span>, or <span>gbk third</span>
 is not 0x00, and the <span>fatal flag</span> is set, return failure.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span>, and one
 <span>gbk first</span>, <span>gbk second</span>, or <span>gbk third</span>
 is not 0x00, set <span>gbk first</span>, <span>gbk second</span>, and
 <span>gbk third</span> to 0x00, and emit the
 <span>fallback code point</span>.

 <li><p>Increase the <span>byte pointer</span>.

 <li>
  <p>If <span>gbk third</span> is not 0x00, run these substeps:

  <ol>
   <li class=XXX><p>If <var title>byte</var> is in the range 0x30 to 0x39,
   ... and there is a code point ...
   set <span>gbk first</span>, <span>gbk second</span>, and
   <span>gbk third</span> to 0x00, and then
   emit ...

   <li><p>If the <span>fatal flag</span> is set, return failure.

   <li><p>Decrease the <span>byte pointer</span> by three, set
   <span>gbk first</span>, <span>gbk second</span>, and
   <span>gbk third</span> to 0x00, and emit the
   <span>fallback code point</span>.
  </ol>

 <li>
  <p>If <span>gbk second</span> is not 0x00, run these substeps:

  <ol>
   <li><p>If <var title>byte</var> is in the range 0x81 to 0xFE, set
   <span>gbk third</span> to <var title>byte</var> and continue.

   <li><p>If the <span>fatal flag</span> is set, return failure.

   <li><p>Decrease the <span>byte pointer</span> by two, set
   <span>gbk first</span> and <span>gbk second</span> to 0x00, and emit the
   <span>fallback code point</span>.
  </ol>

 <li>
  <p>If <span>gbk first</span> is not 0x00, run these substeps:

  <ol>
   <li><p>If <var title>byte</var> is in the range 0x30 to 0x39 and the
   <span>gb18030 flag</span> is set, set <span>gbk second</span> to
   <var title>byte</var> and continue.

   <li class=XXX><p>If <var title>byte</var> is in the range 0x40 to 0xFE,
   ... and there is a code point ... set <span>gbk first</span> to 0x00, and
   then emit ...

   <li><p>If the <span>fatal flag</span> is set, return failure.

   <li><p>Decrease the <span>byte pointer</span> by one, set
   <span>gbk first</span> to 0x00, and emit the
   <span>fallback code point</span>.
  </ol>

 <li><p>If <var title>byte</var> is in the range 0x00 to 0x7F, emit a code
 point whose value is <var title>byte</var>.

 <li>
  <p>If <var title>byte</var> is 0x80 and the <span>gb18030 flag</span> is
  unset, emit a code point whose value is U+20AC.

  <p class=XXX>Gecko emits it regardless of the <span>gb18030 flag</span>.

 <li><p>If <var title>byte</var> is in the range 0x81 to 0xFE, set
 <span>gbk first</span> to <var title>byte</var> and continue.

 <li><p>If the <span>fatal flag</span> is set, return failure.

 <li><p>Emit the <span>fallback code point</span>.
</ol>

<p>The <dfn>gbk encoder</dfn> (<span>encoder</span> for <span>gbk</span>) is:

<ol class=XXX></ol>

<h3><dfn>gb18030</dfn></h3>

<p>The <dfn>gb18030 decoder</dfn> (<span>decoder</span> for <span>gb18030</span>) is
the <span>gbk decoder</span> with the <span>gb18030 flag</span> set.

<p>The <dfn>gb18030 encoder</dfn> (<span>encoder</span> for <span>gb18030</span>) is
the <span>gbk encoder</span> with the <span>gb18030 flag</span> set.


<h3><dfn>hz-gb-2312</dfn></h3>
<!--
 http://tools.ietf.org/html/rfc1842
 http://tools.ietf.org/html/rfc1843
-->

<p>The <dfn>hz-gb-2312 flag</dfn> is initially unset. The
<dfn>hz-gb-2312 lead</dfn> is initially 0x00.</p>

<p>The <dfn>hz-gb-2312 decoder</dfn> (<span>decoder</span> for <span>hz-gb-2312</span>) is:

<ol>
 <li><p>Let <var title>byte</var> be <span>byte pointer</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span> and
 <span>hz-gb-2312 lead</span> is 0x00, emit the
 <span>EOF code point</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span>,
 <span>hz-gb-2312 lead</span> is not 0x00, and the <span>fatal flag</span>
 is set, return failure.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span> and
 <span>hz-gb-2312 lead</span> is not 0x00, set <span>hz-gb-2312 lead</span>
 to 0x00 and emit the <span>fallback code point</span>.

 <li><p>Increase the <span>byte pointer</span>.

 <li>
  <p>If <span>hz-gb-2312 lead</span> is 0x7E, set
  <span>hz-gb-2312 lead</span> to 0x00, and based on <var title>byte</var>:

  <dl class=switch>
   <dt>0x7B<!--{-->
   <dd>Set the <span>hz-gb-2312 flag</span> and continue.

   <dt>0x7D<!--}-->
   <dd>Unset the <span>hz-gb-2312 flag</span> and continue.
   <!--In "ASCII mode" IE outputs ~}, Gecko outputs U+FFFD, Chrome outputs
   a single U+FFFD for ~}~}. Weird. Opera just skips.-->

   <dt>0x7E<!--~-->
   <dd>Emit a U+007E code point.

   <dt>0x0A<!--newline-->
   <dd>Set <span>hz-gb-2312 lead</span> to 0x00 and continue.

   <dt>Otherwise
   <dd>
    <p>If the <span>fatal flag</span> is set, return failure.

    <p>Otherwise, decrease the <span>byte pointer</span> by one and emit
    the <span>fallback code point</span>.
  </dl>

 <li>
  <p>If <span>hz-gb-2312 lead</span> is not 0x00, set
  <span>hz-gb-2312 lead</span> to 0x00 and:

  <ol>
   <li><p class=XXX>Let <var title>code point</var> be
   <span>gbk code point</span> for ...
   <!-- (hz-gb-2312 lead - 1) * 191 + (byte + 0x40) -->

   <li><p>If <var title>byte</var> is in the range 0x20 to 0x7F and
   <var title>code point</var> is not null, emit
   <var title>code point</var>.

   <li><p>If the <span>fatal flag</span> is set, return failure.

   <li><p>If <var title>byte</var> is 0x0A, unset the
   <span>hz-gb-2312 flag</span>.

   <li><p>Emit the <span>fallback code point</span>.
  </ol>

 <li><p>If <var title>byte</var> is 0x7E<!--~-->, set
 <span>hz-gb-2312 lead</span> to 0x7E and continue.

 <li>
  <p>If the <span>hz-gb-2312 flag</span> is set:

  <ol>
   <li><p>If <var title>byte</var> is in the range 0x20 to 0x7F, set
   <span>hz-gb-2312 lead</span> to <var title>byte</var> and continue.

   <li><p>If the <span>fatal flag</span> is set, return failure.

   <li><p>If <var title>byte</var> is 0x0A, unset the
   <span>hz-gb-2312 flag</span>.

   <li><p>Emit the <span>fallback code point</span>.
  </ol>

 <li><p>If <var title>byte</var> is in the range 0x00 to 0x7F, emit a
 code point whose value is <var title>byte</var>.

 <li><p>If the <span>fatal flag</span> is set, return failure.

 <li><p>Emit the <span>fallback code point</span>.
</ol>

<p>The <dfn>hz-gb-2312 encoder</dfn> (<span>encoder</span> for <span>hz-gb-2312</span>) is:

<ol class=XXX></ol>


<h3><dfn>iso-2022-cn</dfn></h3>
<!-- http://tools.ietf.org/html/rfc1922 -->

<p class=XXX>...


<h2>Legacy multi-byte Chinese (traditional) encodings</h2>


<h3><dfn>big5</dfn></h3><!-- cp950 -->

<p class=XXX>The <dfn>big5 code point</dfn> for two bytes
(<var title>byte<sub>1</sub></var>, <var title>byte<sub>2</sub></var>) is
...

<p class=XXX>Include Gecko extensions? https://bugzilla.mozilla.org/show_bug.cgi?id=310299

<p>The <dfn>big5 lead</dfn> is initially 0x00.

<p>The <dfn>big5 decoder</dfn> (<span>decoder</span> for <span>big5</span>) is:
<!-- identical to euc-kr -->

<ol>
 <li><p>Let <var title>byte</var> be <span>byte pointer</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span> and
 <span>big5 lead</span> is 0x00, emit the
 <span>EOF code point</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span>,
 <span>big5 lead</span> is not 0x00, and the <span>fatal flag</span> is
 set, return failure.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span>,
 <span>big5 lead</span> is not 0x00, set <span>big5 lead</span> to 0x00 and
 emit the <span>fallback code point</span>.

 <li><p>Increase the <span>byte pointer</span> by one.

 <li><p>If <span>big5 lead</span> is 0x00 and <var title>byte</var> is
 in the range 0x00 to 0x7F, emit a code point whose value is
 <var title>byte</var>.

 <li><p>If <span>big5 lead</span> is 0x00, set <span>big5 lead</span>
 to <var title>byte</var> and continue.

 <li><p>Let <var title>code point</var> be the
 <span>big5 code point</span> for
 (<span>big5 lead</span>, <var title>byte</var>).

 <li><p>Set <span>big5 lead</span> to 0x00.

 <li><p>If <var title>code point</var> is not null, emit
 <var title>code point</var>.

 <li><p>If the <span>fatal flag</span> is set, return failure.

 <li><p>If <var title>byte</var> is in the range 0x00 0x7F, decrease the
 <span>byte pointer</span> by one.

 <li><p>Emit the <span>fallback code point</span>.
</ol>

<p>The <dfn>big5 encoder</dfn> (<span>encoder</span> for <span>big5</span>) is:

<ol class=XXX></ol>


<h3><dfn>big5-hkscs</dfn></h3>

<p class=XXX>Not supported by IE, supported by everyone else.
https://bugzilla.mozilla.org/show_bug.cgi?id=310299#c5
http://www.google.com/support/forum/p/Chrome/thread?tid=466c210af3fb6d08
http://w3techs.com/technologies/details/en-b5hkscs/all/all


<h2>Legacy multi-byte Japanese encodings</h2>

<p class=XXX>The <dfn>jis code point</dfn> for a given number is: ...</p>

<p>The <dfn>jis0208 index</dfn> for a given <var title>byte</var> is:
<!-- only valid in range A1-FE -->

<dl class=switch>
 <dt>0xA1 to 0xA2
 <dd><!--8648-->(<var title>byte</var> &minus; 0x45) &times; 94

 <dt>0xA3 to 0xA8
 <dd><!--376-->(<var title>byte</var> &minus; 0x9F) &times; 94

 <dt>0xAD
 <dd>940

 <dt>0xB1 to 0xF4
 <dd><!--1222-->(<var title>byte</var> &minus; 0xA4) &times; 94

 <dt>0xF9 to 0xFC
 <dd><!--7708-->(<var title>byte</var> &minus; 0xA7) &times; 94

 <dt>Otherwise
 <dd>null
</dl>

<p>The <dfn>jis0212 index</dfn> for a given <var title>byte</var> is:
<!-- only valid in range A1-FE -->

<dl class=switch>
 <dt>0xA2
 <dd>9400
 <dt>0xA6 to 0xA7
 <dd><!--9494-->(<var title>byte</var> &minus; 0x41) &times; 94
 <dt>0xA9 to 0xAB
 <dd><!--9682-->(<var title>byte</var> &minus; 0x42) &times; 94
 <dt>0xB0 to 0xED
 <dd><!--9964-->(<var title>byte</var> &minus; 0x46) &times; 94
 <dt>Otherwise
 <dd>null
</dl>


<h3><dfn>euc-jp</dfn></h3>

<p>The <dfn>euc-jp offset</dfn> for a given <var title>byte</var> is null
if <var title>byte</var> &minus; 0xA1 is greater than 93 or less than 0, or
otherwise the result of that equation.

<p>The <dfn>euc-jp first</dfn> and <dfn>euc-jp second</dfn> are 0x00.

<p>The <dfn>euc-jp decoder</dfn> (<span>decoder</span> for <span>euc-jp</span>) is:

<ol>
 <li><p>Let <var title>byte</var> be <span>byte pointer</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span> and
 <span>euc-jp first</span> and <span>euc-jp second</span> are 0x00, emit the
 <span>EOF code point</span>.

 <li><p>If <var title>byte</var> is either the <span>EOF byte</span> or is
 in the range 0x00 to 0x7F, either <span>euc-jp first</span> or
 <span>euc-jp second</span> is not 0x00, and the <span>fatal flag</span> is
 set, return failure.

 <li><p>If <var title>byte</var> is either the <span>EOF byte</span> or is
 in the range 0x00 to 0x7F, and <span>euc-jp second</span> is 0x00,
 set <span>euc-jp first</span> to 0x00 and emit the
 <span>fallback code point</span>.

 <li><p>If <var title>byte</var> is either the <span>EOF byte</span> or is
 in the range 0x00 to 0x7F, and <span>euc-jp second</span> is not 0x00, set
 <span>euc-jp first</span> and <span>euc-jp second</span> to 0x00, decrease
 the <span>byte pointer</span> by one, and emit the
 <span>fallback code point</span>.

 <li><p>Increase the <span>byte pointer</span> by one.

 <li>
  <p>If <span>euc-jp second</span> is not 0x00, run these substeps:
  <!--euc-jp first must be 0x8E-->

  <ol>
   <li><p>Let <var title>lead</var> be the <span>jis0212 index</span> for
   <span>euc-jp second</span> and <var title>offset</var> be the
   <span>euc-jp offset</span> for <var title>byte</var>.

   <li><p>If either <var title>lead</var> or <var title>byte</var> is null,
   and the <span>fatal flag</span> is set, return failure.

   <li><p>If either <var title>lead</var> or <var title>offset</var> is
   null, emit the <span>fallback code point</span>.

   <li><p>Let <var title>code point</var> be the
   <span>jis code point</span> for <var title>lead</var> plus
   <var title>offset</var>.

   <li><p>If <var title>code point</var> is null and the
   <span>fatal flag</span> is set, return failure.

   <li><p>If <var title>code point</var> is null, emit the
   <span>fallback code point</span>.

   <li><p>Emit <var title>code point</var>.
  </ol>

 <li><p>If <span>euc-jp first</span> is 0x8E and <var title>byte</var> is
 in the range 0xA1 to 0xDF, emit a code point whose value is 0xFEC0 +
 <var title>byte</var>.

 <li><p>If <span>euc-jp first</span> is 0x8F and <var title>byte</var> is
 in the range 0xA1 to 0xFE, set <span>euc-jp second</span> to
 <var title>byte</var> and continue.

 <li>
  <p>If <span>euc-jp first</span> is in the range 0xA1 to 0xFE, run these
  substeps:

  <ol>
   <li><p>Let <var title>lead</var> be the <span>jis0208 index</span> for
   <span>euc-jp first</span> and <var title>offset</var> the
   <span>euc-jp offset</span> for <var title>byte</var>.

   <li><p>If the <span>fatal flag</span> is set and either
   <var title>lead</var> or <var title>offset</var> is null, return failure.

   <li><p>If either <var title>lead</var> or <var title>offset</var> is
   null, emit the <span>fallback code point</span>.

   <li><p>Let <var title>code point</var> be the
   <span>jis code point</span> for <var title>lead</var> plus
   <var title>offset</var>.

   <li><p>If <var title>code point</var> is null and the
   <span>fatal flag</span> is set, return failure.

   <li><p>If <var title>code point</var> is null, emit the
   <span>fallback code point</span>.

   <li><p>Emit <var title>code point</var>.
  </ol>

 <li><p>If <var title>byte</var> is in the range 0x00 to 0x7F, emit a
 code point whose value is <var title>byte</var>.

 <li><p>If <var title>byte</var> is 0x8E, 0x8F, or in the range 0xA1 to
 0xFE, set <span>euc-jp first</span> to <var title>byte</var> and continue.

 <li><p>If the <span>fatal flag</span> is set, return failure.

 <li><p>Set <span>euc-jp first</span> to 0x00 and emit the
 <span>fallback code point</span>.
</ol>

<p>The <dfn>euc-jp encoder</dfn> (<span>encoder</span> for <span>euc-jp</span>) is:

<ol class=XXX>
</ol>

<p class=XXX>https://bugzilla.mozilla.org/show_bug.cgi?id=600715 encoder is more restrictive.


<h3><dfn>iso-2022-jp</dfn></h3>
<!--
 http://tools.ietf.org/html/rfc1468
 http://tools.ietf.org/html/rfc2237 (iso-2022-jp-1)
-->

<p>The <dfn>iso-2022-jp offset</dfn> for a given <var title>byte</var> is
null if <var title>byte</var> &minus; 0x21 is greater than 93 or less than
0, or otherwise the result of that equation.

<p>The <dfn>iso-2022-jp state</dfn> is initially <b title>ASCII state</b>.

<p>The <dfn>iso-2022-jp jis0212 flag</dfn> is initially unset.

<p>The <dfn>iso-2022-jp lead</dfn> is initially 0x00.

<p>The <dfn>iso-2022-jp decoder</dfn> (<span>decoder</span> for <span>iso-2022-jp</span>) is:

<ol>
 <li><p>Let <var title>byte</var> be <span>byte pointer</span>.

 <li><p>If <var title>byte</var> is not the <span>EOF byte</span>,
 increase the <span>byte pointer</span> by one.

 <li>
  <p>Based on <span>iso-2022-jp state</span>:

  <dl class=switch>
   <dt>ASCII state

   <dd>
    <p>Based on <var title>byte</var>:

    <dl class=switch>
     <dt>0x1B
     <dd><p>Set <span>iso-2022-jp state</span> to
     <b title>escape start state</b> and continue.

     <dt>0x00 to 0x7E
     <dd><p>Emit a code point whose value is <var title>byte</var>.

     <dt><span>EOF byte</span>
     <dd><p>Emit the <span>EOF code point</span>.

     <dt>Otherwise
     <dd>
      <p>If the <span>fatal flag</span> is set, return failure.

      <p>Otherwise, emit the <span>fallback code point</span>.
    </dl>

   <dt>Escape start state
   <dd>
    <ol>
     <li><p>If <var title>byte</var> is either <!--$-->0x24 or
     <!--(-->0x28, set <span>iso-2022-jp lead</span> to
     <var title>byte</var>, <span>iso-2022-jp state</span> to
     <b title>escape middle state</b>, and continue.

     <li><p>If the <span>fatal flag</span> is set, return failure.

     <li><p>If <var title>byte</var> is not the <span>EOF byte</span>,
     decrease the <span>byte pointer</span> by one.

     <li><p>Set <span>iso-2022-jp state</span> to <b title>ASCII state</b>
     and emit the <span>fallback code point</span>.
    </ol>

   <dt>Escape middle state
   <dd>
    <ol>
     <li><p>Let <var title>lead</var> be <span>iso-2022-jp lead</span> and
     set <span>iso-2022-jp lead</span> to 0x00.

     <li><p>If <var title>lead</var> is 0x24 and <var title>byte</var> is
     either 0x40<!--@--> or 0x42<!--B-->, unset the
     <span>iso-2022-jp jis0212 flag</span>, set
     <span>iso-2022-jp state</span> to <b title>lead state</b>, and
     continue.

     <li><p>If <var title>lead</var> is 0x24 and <var title>byte</var> is
     0x28, set <span>iso-2022-jp state</span> to
     <b title>escape final state</b> and continue.

     <li><p>If <var title>lead</var> is 0x28 and <var title>byte</var> is
     either 0x42<!--B--> or 0x4A<!--J-->, set <span>iso-2022-jp state</span>
     to <b title>ASCII state</b> and continue.

     <li><p>If <var title>lead</var> is 0x28 and <var title>byte</var> is
     0x49<!--I-->, set <span>iso-2022-jp state</span> to
     <b title>Katakana state</b> and continue.

     <li><p>If the <span>fatal flag</span> is set, return failure.

     <li><p>If <var title>byte</var> is the <span>EOF byte</span>,
     decrease <span>byte pointer</span> by one, or otherwise decrease it by
     two.

     <li><p>Set <span>iso-2022-jp state</span> to <b title>ASCII state</b>
     and emit the <span>fallback code point</span>.
    </ol>

   <dt>Escape final state
   <dd>
    <ol>
     <li><p>If <var title>byte</var> is 0x44<!--D-->, set the
     <span>iso-2022-jp jis0212 flag</span>, set
     <span>iso-2022-jp state</span> to <b title>lead state</b>, and
     continue.

     <li><p>If the <span>fatal flag</span> is set, return failure.

     <li><p>If <var title>byte</var> is the <span>EOF byte</span>,
     decrease <span>byte pointer</span> by two, or otherwise decrease it by
     three.

     <li><p>Set <span>iso-2022-jp state</span> to <b title>ASCII state</b>
     and emit the <span>fallback code point</span>.
    </ol>

   <dt>Lead state
   <dd>
    <p>Based on <var title>byte</var>:
    <dl class=switch>
     <dt>0x0A
     <dd>
      <p>If the <span>fatal flag</span> is set, return failure.

      <p>Otherwise, set <span>iso-2022-jp state</span> to
      <b title>ASCII state</b> and emit a code point whose value is U+000A.

     <dt>0x1B
     <dd><p>Set <span>iso-2022-jp state</span> to <b title>escape state</b>
     and continue.

     <dt><span>EOF byte</span>
     <dd><p>Emit the <span>EOF code point</span>.

     <dt>Otherwise
     <dd>
      <p>If the <span>iso-2022-jp jis0212 flag</span> is set, set
      <span>iso-2022-jp lead</span> to the <span>jis0212 index</span> for
      <var title>byte</var>, or otherwise set <span>iso-2022-jp lead</span>
      to the <span>jis0208 index</span> for <var title>byte</var>.

      <p>Then set <span>iso-2022-jp state</span> to
      <b title>trail state</b>, and continue.
    </dl>

   <dt>Trail state
   <dd>
    <ol>
     <li><p>Set the <span>iso-2022-jp state</span> to
     <b title>lead state</b>.

     <li><p>If <var title>byte</var> is the <span>EOF byte</span> and the
     <span>fatal flag</span> is set, return failure.

     <li><p>If <var title>byte</var> is the <span>EOF byte</span>, emit
     the <span>fallback code point</span>.

     <li><p>Let <var title>lead</var> be the <span>iso-2022-jp lead</span>
     and <var title>offset</var> the <span>iso-2022-jp offset</span> for
     <var title>byte</var>.

     <li><p>If the <span>fatal flag</span> is set and either
     <var title>lead</var> or <var title>offset</var> is null,
     return failure.

     <li><p>If either <var title>lead</var> or <var title>offset</var> is
     null, emit the <span>fallback code point</span>.

     <li><p>Let <var title>code point</var> be the
     <span>jis code point</span> for <var title>lead</var> plus
     <var title>offset</var>.

     <li><p>If <var title>code point</var> is null and the
     <span>fatal flag</span> is set, return failure.

     <li><p>If <var title>code point</var> is null, emit the
     <span>fallback code point</span>.

     <li><p>Emit <var title>code point</var>.
    </ol>

   <dt>Katakana state
   <dd>
    <p>Based on <var title>byte</var>:
    <dl class=switch>
     <dt>0x1B
     <dd><p>Set <span>iso-2022-jp state</span> to <b title>escape state</b>
     and continue.

     <dt>0x21 to 0x5F
     <dd><p>Emit a code point whose value is 0xFF40 +
     <var title>byte</var>.

     <dt><span>EOF byte</span>
     <dd><p>Emit the <span>EOF code point</span>.

     <dt>Otherwise
     <dd>
      <p>If the <span>fatal flag</span> is set, return failure.

      <p>Otherwise, emit the <span>fallback code point</span>.
    </dl>
  </dl>
</ol>

<p>The <dfn>iso-2022-jp encoder</dfn> (<span>encoder</span> for <span>iso-2022-jp</span>) is:

<ol class=XXX></ol>


<h3><dfn>shift_jis</dfn></h3>

<p>The <dfn>shift_jis fallback code point</dfn> is U+30FB.</p>

<p>The <dfn>shift_jis lead byte index or code point</dfn> for a given
<var title>byte</var> is:</p>

<dl class=switch>
 <dt>0x81
 <dd>8648

 <dt>0x82 to 0x84
 <dd>(<var title>byte</var> &minus; 0x80) &times; 188

 <dt>0x87 to 0x9F
 <dd>(<var title>byte</var> &minus; 0x82) &times; 188

 <dt>0xA0
 <dd>0xF8F0

 <dt>0xA1 to 0xDF
 <dd>0xFEC0 + <var title>byte</var>

 <dt>0xE1 to 0xEA
 <dd>(<var title>byte</var> &minus; 0xC2) &times; 188

 <dt>0xED to 0xEE
 <dd>(<var title>byte</var> &minus; 0xC4) &times; 188

 <dt>0xF0 to 0xF9
 <dd>0xE000 + (<var title>byte</var> &minus; 0xF0) &times; 188

 <dt>0xFA to 0xFC
 <dd>(<var title>byte</var> &minus; 0xCF) &times; 188

  <dt>0xFD to 0xFF
  <dd>0xF7F4 + <var title>byte</var>

  <dt>Otherwise
  <dd>null
</dl>

<p>The <dfn>shift_jis offset</dfn> for a given <var title>byte</var> is:

<dl class=switch>
 <dt>0x40 to 0x7E</dt>
 <dd><var title>byte</var> &minus; 0x40

 <dt>0x80 to 0x7C</dt>
 <dd><var title>byte</var> &minus; 0x41

 <dt>Otherwise</dt>
 <dd>null
</dl>

<p>The <dfn>shift_jis lead</dfn> is initially 0x00.

<p>The <dfn>shift_jis decoder</dfn> (<span>decoder</span> for <span>shift_jis</span>) is:

<ol>
 <li><p>Let <var title>byte</var> be <span>byte pointer</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span> and
 <span>shift_jis lead</span> is 0x00, emit the
 <span>EOF code point</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span>,
 <span>shift_jis lead</span> is not 0x00, and the <span>fatal flag</span> is
 set, return failure.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span>,
 <span>shift_jis lead</span> is not 0x00, emit the
 <span>fallback code point</span>.

 <li><p>Increase the <span>byte pointer</span> by one.

 <li><p>If <span>shift_jis lead</span> is 0x00 and <var title>byte</var> is
 in the range 0x00 to 0x80, emit a code point whose value is
 <var title>byte</var>.

 <li><p>If <span>shift_jis lead</span> is 0x00, set
 <span>shift_jis lead</span> to the
 <span>shift_jis lead byte index or code point</span> for
 <var title>byte</var> and continue.

 <li>
  <p>If <span>shift_jis lead</span> is either less than 0xF8F0 or null, run
  these substeps:

  <ol>
   <li><p>Let <var title>offset</var> be the
   <span>shift_jis offset</span> for <var title>byte</var>.

   <li><p>If either <var title>offset</var> or <span>shift_jis lead</span>
   is null and the <span>fatal flag</span> is set, return failure.

   <li><p>If <var title>offset</var> is null, set
   <span>shift_jis lead</span> to 0x00, decrease the
   <span>byte pointer</span> by one and emit the
   <span>fallback code point</span>.

   <li><p>If <span>shift_jis lead</span> is equal or more than 0xE000, emit
   a code point whose value is <var title>lead</var> plus
   <var title>offset</var>.

   <li><p>Otherwise, if <span>shift_jis lead</span> is null, emit a
   <span>shift_jis fallback code point</span>.

   <li><p>Otherwise, let <var title>code point</var> be the
   <span>jis code point</span> for <span>shift_jis lead</span> plus
   <var title>offset</var>.

   <li><p>If <var title>code point</var> is null and the
   <span>fatal flag</span> is set, return failure.

   <li><p>If <var title>code point</var> is null, emit a
   <span>shift_jis fallback code point</span>.

   <li><p>Emit <var title>code point</var>.
  </ol>

 <li><p>Otherwise, emit a code point whose value is
 <span>shift_jis lead</span>.
</ol>

<p>The <dfn>shift_jis encoder</dfn> (<span>encoder</span> for <span>shift_jis</span>) is:

<ol class=XXX></ol>


<h2>Legacy multi-byte Korean encodings</h2>

<p class=XXX>The <dfn>euc-kr code point</dfn> for two bytes
(<var title>byte<sub>1</sub></var>, <var title>byte<sub>2</sub></var>) is
...

<h3><dfn>euc-kr</dfn></h3><!-- cp949 -->

<p>The <dfn>euc-kr lead</dfn> is initially 0x00.

<p>The <dfn>euc-kr decoder</dfn> (<span>decoder</span> for <span>euc-kr</span>) is:
<!-- identical to big5 -->

<ol>
 <li><p>Let <var title>byte</var> be <span>byte pointer</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span> and
 <span>euc-kr lead</span> is 0x00, emit the
 <span>EOF code point</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span>,
 <span>euc-kr lead</span> is not 0x00, and the <span>fatal flag</span> is
 set, return failure.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span>,
 <span>euc-kr lead</span> is not 0x00, emit the
 <span>fallback code point</span>.

 <li><p>Increase the <span>byte pointer</span> by one.

 <li><p>If <span>euc-kr lead</span> is 0x00 and <var title>byte</var> is
 in the range 0x00 to 0x7F, emit a code point whose value is
 <var title>byte</var>.

 <li><p>If <span>euc-kr lead</span> is 0x00, set <span>euc-kr lead</span>
 to <var title>byte</var> and continue.

 <li><p>Let <var title>code point</var> be the
 <span>euc-kr code point</span> for
 (<span>euc-kr lead</span>, <var title>byte</var>).

 <li><p>Set <span>euc-kr lead</span> to 0x00.

 <li><p>If <var title>code point</var> is not null, emit
 <var title>code point</var>.

 <li><p>If the <span>fatal flag</span> is set, return failure.

 <li><p>If <var title>byte</var> is in the range 0x00 0x7F, decrease the
 <span>byte pointer</span> by one.

 <li><p>Emit the <span>fallback code point</span>.
</ol>

<p>The <dfn>euc-kr encoder</dfn> (<span>encoder</span> for <span>euc-kr</span>) is:

<ol class=XXX></ol>


<h3><dfn>iso-2022-kr</dfn></h3>

<!--XXX the "ESC $ ) C" sequence is only supported by Gecko at the start of
a stream. It does exactly nothing. Trying to get away with not supporting it
at all.-->

<p>The <dfn>iso-2022-kr state</dfn> is initially <b title>ASCII state</b>.

<p>The <dfn>iso-2022-kr lead</dfn> is initially 0x00.

<p>The <dfn>iso-2022-kr decoder</dfn> (<span>decoder</span> for <span>iso-2022-kr</span>) is:

<ol>
 <li><p>Let <var title>byte</var> be <span>byte pointer</span>.

 <li><p>If <var title>byte</var> is not the <span>EOF byte</span>,
 increase the <span>byte pointer</span> by one.

 <li>
  <p>Based on <span>iso-2022-kr state</span>:

  <dl class=switch>
   <dt>ASCII state

   <dd>
    <p>Based on <var title>byte</var>:

    <dl class=switch>
     <dt>0x0E
     <dd><p>Set <span>iso-2022-kr state</span> to <b title>lead state</b>
     and continue.

     <dt>0x0F
     <dd><p>Continue.

     <dt>0x00 to 0x7E
     <dd><p>Emit a code point whose value is <var title>byte</var>.

     <dt><span>EOF byte</span>
     <dd><p>Emit the <span>EOF code point</span>.

     <dt>Otherwise
     <dd>
      <p>If the <span>fatal flag</span> is set, return failure.

      <p>Otherwise, emit the <span>fallback code point</span>.
    </dl>

   <dt>Lead state
   <dd>
    <p>Based on <var title>byte</var>:
    <dl class=switch>
     <dt>0x0A
     <dd>
      <p>If the <span>fatal flag</span> is set, return failure.

      <p>Otherwise, set <span>iso-2022-kr state</span> to
      <b title>ASCII state</b> and emit a code point whose value is U+000A.

     <dt>0x0E
     <dd><p>Continue.

     <dt>0x0F
     <dd><p>Set <span>iso-2022-kr state</span> to <b title>ASCII state</b>
     and continue.

     <dt><span>EOF byte</span>
     <dd><p>Emit the <span>EOF code point</span>.

     <dt>Otherwise
     <dd>
      <p>Set <span>iso-2022-kr lead</span> to <var title>byte</var>, set
      <span>iso-2022-kr state</span> to <b title>trail state</b>, and
      continue.
    </dl>

   <dt>Trail state
   <dd>
    <ol>
     <li><p>Set the <span>iso-2022-kr state</span> to
     <b title>lead state</b>.

     <li><p>If <var title>byte</var> is the <span>EOF byte</span> and the
     <span>fatal flag</span> is set, return failure.

     <li><p>If <var title>byte</var> is the <span>EOF byte</span>, emit
     the <span>fallback code point</span>.

     <li><p>If either <span>iso-2022-kr lead</span> or
     <var title>byte</var> is not in the range 0x21 to 0x7E, let
     <var title>code point</var> be null, or otherwise let
     <var title>code point</var> be the <span>euc-kr code point</span> for
     (<span>iso-2022-kr lead</span> + 0x80, <var title>byte</var> + 0x80).

     <li><p>If <var title>code point</var> is not null, emit
     <var title>code point</var>.

     <li><p>If the <span>fatal flag</span> is set, return failure.

     <li><p>Emit the <span>fallback code point</span>.
    </ol>
  </dl>
</ol>

<p>The <dfn>iso-2022-kr encoder</dfn> (<span>encoder</span> for <span>iso-2022-kr</span>) is:

<ol class=XXX></ol>


<h2>Legacy utf-16 encodings</h2>

<p class=note>Contrary to the Unicode standard, checking for a BOM happens
before an encoding to decode a byte stream is chosen.


<h3><dfn>utf-16</dfn></h3>

<p>The <dfn>utf-16 lead byte</dfn> and <dfn>utf-16 lead surrogate</dfn>
are initially null and the <dfn>utf-16be flag</dfn> is initially unset.

<p>The <dfn>utf-16 decoder</dfn> (<span>decoder</span> for <span>utf-16</span>) is:

<ol>
 <li><p>Let <var title>byte</var> be <span>byte pointer</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span> and
 <span>utf-16 lead byte</span> and <span>utf-16 lead surrogate</span> are
 null, emit the <span>EOF code point</span>.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span>, either
 <span>utf-16 lead byte</span> or <span>utf-16 lead surrogate</span> is not
 null, and the <span>fatal flag</span> is set, return failure.

 <li><p>If <var title>byte</var> is the <span>EOF byte</span>, and either
 <span>utf-16 lead byte</span> or <span>utf-16 lead surrogate</span> is not
 null, emit the <span>fallback code point</span>, and then emit the
 <span>EOF code point</span>.

 <li><p>Increase the <span>byte pointer</span> by one.

 <li><p>If <span>utf-16 lead byte</span> is null, set
 <span>utf-16 lead byte</span> to <var title>byte</var> and continue.

 <li>
  <p>Let <var title>code point</var> be the result of:

  <dl class=switch>
   <dt><span>utf-16be flag</span> is set
   <dd><p>The arithmetic left shift of <span>utf-16 lead byte</span> by 8 +
   <var title>byte</var>.
   <dt><span>utf-16be flag</span> is unset
   <dd><p>The arithmetic left shift of <var title>byte</var> by 8 +
   <span>utf-16 lead byte</span>.
  </dl>

  <p>Then set <span>utf-16 lead byte</span> to null.

 <li>
  <p>If <span>utf-16 lead surrogate</span> is not null, let
  <var title>lead surrogate</var> be <span>utf-16 lead surrogate</span>, set
  <span>utf-16 lead surrogate</span> to null, and then run these substeps:

  <ol>
   <li><p>If <var title>code point</var> is in the range U+DC00 to U+DFFF,
   emit a code point whose value is
   0x10000 + (<var title>lead surrogate</var> &minus; 0xD800) &times; 0x400 + (<var title>code point</var> &minus; 0xDC00).

   <li><p>If the <span>fatal flag</span> is set, return failure.

   <li><p>Decrease the <span>byte pointer</span> by two and emit the
   <span>fallback code point</span>.
   <!-- unpaired surrogates; IE/WebKit output them, Gecko/Opera FFFD them -->
  </ol>

 <li><p>If <var title>code point</var> is in the range U+D800 to U+DBFF, set
 <span>utf-16 lead surrogate</span> to <var title>code point</var> and
 continue.

 <li><p>If <var title>code point</var> is in the range U+DC00 to U+DFFF and
 the <span>fatal flag</span> is set, return failure.

 <li><p>If <var title>code point</var> is in the range U+DC00 to U+DFFF,
 emit the <span>fallback code point</span>.
 <!-- unpaired surrogates; IE/WebKit output them, Gecko/Opera FFFD them -->

 <li><p>Emit code point <var title>code point</var>.
</ol>

<p>To <dfn>convert a <var title>code unit</var> to bytes</dfn> run these steps:

<ol>
 <li><p>Let <var title>byte1</var> be the arithmetic right shift of
 <var title>code point</var> by 8.

 <li><p>Let <var title>byte2</var> be <var title>code point</var>
 bitwise AND 0x00FF.

 <li>
  <p>Then return the bytes in order:

  <dl class=switch>
   <dt><span>utf-16be flag</span> is set
   <dd><p><var title>byte1</var>, then <var title>byte2</var>.
   <dt><span>utf-16be flag</span> is unset
   <dd><p><var title>byte2</var>, then <var title>byte1</var>.
  </dl>
</ol>

<p>The <dfn>utf-16 encoder</dfn> (<span>encoder</span> for <span>utf-16</span>) is:

<ol>
 <li><p>Let <var title>code point</var> be <span>code point pointer</span>.

 <li><p>If <var title>code point</var> is in the range 0xD800 to 0xDFFF,
 return failure.

 <li><p>If <var title>code point</var> is the <span>EOF code point</span>,
 emit the <span>EOF byte</span>.

 <li><p>Increase the <span>code point pointer</span> by one.

 <li><p>If <var title>code point</var> is in the range 0x00 to 0xFFFF, emit
 the sequence resulting of
 <span title="convert a code unit to bytes">converting <var title>code point</var> to bytes</span>.

 <li><p>Let <var title>lead</var> be
 (<var title>code point</var> &minus; 0x10000) divided by 0x400 + 0xD800,
 <span title="convert a code unit to bytes">converted to bytes</span>.

 <li><p>Let <var title>trail</var> be the remainder of dividing
 (<var title>code point</var> &minus; 0x10000) by 0x400 + 0xDC00,
 <span title="convert a code unit to bytes">converted to bytes</span>.

 <li><p>Emit a sequence of bytes that consists of <var title>lead</var>
 followed by <var title>trail</var>.
</ol>


<h3><dfn>utf-16be</dfn></h3>

<p>The <dfn>utf-16be decoder</dfn> (<span>decoder</span> for <span>utf-16be</span>)
is the <span>utf-16 decoder</span> with the <span>utf-16be flag</span> set.

<p>The <dfn>utf-16be encoder</dfn> (<span>encoder</span> for <span>utf-16be</span>)
is the <span>utf-16 encoder</span> with the <span>utf-16be flag</span> set.


<h2 class=no-num>References</h2>

<div id=anolis-references></div>


<h2 class=no-num>Acknowledgments</h2>

<p>There have been a lot of people that have helped make encodings more
interoperable over the years and thereby furthered the goals of this
standard. Likewise people have helped making this standard what it is today.

<p>Ideally they are all listed here so please contact the editor with any
omissions.

<p>With that, many thanks to

Erik van der Poel,
譚永鋒 (Frank Yung-Fong Tang),
Ian Hickson,
신정식 (Jungshik Shin),
Mark Callow,
Mark Davis,
Martin Dürst,
Masatoshi Kimura,
Ms2ger,
Øistein E. Andersen,
Peter Krefting,
Philip Taylor,
Shawn Steele,
Simon Montagu,
Simon Pieters, and
成瀬ゆい (Yui Naruse)

for being awesome.

<p class=XXX>Clearly not complete at this point, but better than nothing.


<script id=head src=http://www.whatwg.org/specs/web-apps/current-work/dfn.js class=dontpublish></script>
